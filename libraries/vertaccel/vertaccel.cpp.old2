#include "vertaccel.h"

#include <Arduino.h>
#include <Wire.h>

#include <inv_mpu.h>
#include <inv_mpu_dmp_motion_driver.h>

#include <FlashAsEEPROM.h>


/******************/
/* data variables */
/******************/

/* calibration */
static double accelCal[3];

static boolean newData;

/* vertical acceleration */
static double va;


/*************************/
/* calibration functions */
/*************************/

/* read calibration from EEPROM */
void vertaccel_readCalibration(void) {

  /* check tag */
  uint16_t eepromTag;
  eepromTag = EEPROM.read(VERTACCEL_EPROM_ADDR);
  eepromTag <<= 8;
  eepromTag += EEPROM.read(VERTACCEL_EPROM_ADDR + 0x01);
  
  if( eepromTag != VERTACCEL_EPROM_TAG ) {
    accelCal[0] = 0.0;
    accelCal[1] = 0.0;
    accelCal[2] = 0.0;
  } else {
    /* read calibration settings */
    uint8_t* datap = (uint8_t*)accelCal;
    for( unsigned i = 0; i<sizeof(accelCal); i++ ) {
      datap[i] =  EEPROM.read(VERTACCEL_EPROM_ADDR + 0x02 + i);
    }
  }
}

/* save calibration to EEPROM */
void vertaccel_saveCalibration(double* cal) {

  /* write tag */
  uint16_t eepromTag = VERTACCEL_EPROM_TAG;
  EEPROM.write(VERTACCEL_EPROM_ADDR, (eepromTag>>8) & 0xff);
  EEPROM.write(VERTACCEL_EPROM_ADDR + 0x01, eepromTag & 0xff);

  /* save calibration settings */
  uint8_t* datap = (uint8_t*)cal;
  for( unsigned i = 0; i<3*sizeof(double); i++ ) {
    EEPROM.write(VERTACCEL_EPROM_ADDR + 0x02 + i, datap[i]);
  }

  /* save in global var */
  accelCal[0] = cal[0];
  accelCal[1] = cal[1];
  accelCal[2] = cal[2];
} 

/* give calibration coefficients */
double* vertaccel_getCalibration(void) {

  return accelCal;
}  
 

/********************/
/* public functions */
/********************/

/* init vertaccel */
inv_error_t vertaccel_init(boolean giroCalibration) {

  /* setting imu */
	inv_error_t result;
    struct int_param_s int_param;
	
	Wire.begin();
	result = mpu_init(&int_param);	
	if (result)
		return result;
	
	mpu_set_bypass(1); // Place all slaves (including compass) on primary bus
	setSensors(INV_XYZ_GYRO | INV_XYZ_ACCEL | INV_XYZ_COMPASS);
	_gSense = getGyroSens();
	_aSense = getAccelSens();
		
	
  /* setting dmp */
	unsigned short feat = DMP_FEATURE_6X_LP_QUAT | // Enable 6-axis quat
						  DMP_FEATURE_GYRO_CAL;
	unsigned short rate = 10;
	
	if (dmpLoad() != INV_SUCCESS)
		return INV_ERROR;
	
	// 3-axis and 6-axis LP quat are mutually exclusive.
	// If both are selected, default to 3-axis
	if (feat & DMP_FEATURE_LP_QUAT)
	{
		feat &= ~(DMP_FEATURE_6X_LP_QUAT);
		dmp_enable_lp_quat(1);
	}
	else if (feat & DMP_FEATURE_6X_LP_QUAT)
		dmp_enable_6x_lp_quat(1);
	
	if (feat & DMP_FEATURE_GYRO_CAL)
		dmp_enable_gyro_cal(1);
	
	if (dmpEnableFeatures(feat) != INV_SUCCESS)
		return INV_ERROR;
	
	rate = constrain(rate, 1, 200);
	if (dmpSetFifoRate(rate) != INV_SUCCESS)
		return INV_ERROR;
	
	mpu_set_dmp_state(1);

/*	if( giroCalibration ) {
    dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT|DMP_FEATURE_SEND_RAW_ACCEL|DMP_FEATURE_GYRO_CAL); 
  } else {
    dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT|DMP_FEATURE_SEND_RAW_ACCEL);
  }*/

  /* init calibration settings */
 
 vertaccel_readCalibration();
  
  /* init data variables */
  newData = false;
}

inv_error_t dmpSetFifoRate(unsigned short rate)
{
	if (rate > MAX_DMP_SAMPLE_RATE) rate = MAX_DMP_SAMPLE_RATE;
	return dmp_set_fifo_rate(rate);
}

inv_error_t dmpEnableFeatures(unsigned short mask)
{
	unsigned short enMask = 0;
	enMask |= mask;
	// Combat known issue where fifo sample rate is incorrect
	// unless tap is enabled in the DMP.
	enMask |= DMP_FEATURE_TAP; 
	return dmp_enable_feature(enMask);
}

inv_error_t dmpLoad(void)
{
	return dmp_load_motion_driver_firmware();
}

unsigned short getAccelSens(void)
{
	unsigned short sens;
	if (mpu_get_accel_sens(&sens) == INV_SUCCESS)
	{
		return sens;
	}
	return 0;
}

float getGyroSens(void)
{
	float sens;
	if (mpu_get_gyro_sens(&sens) == INV_SUCCESS)
	{
		return sens;
	}
	return 0;
}

inv_error_t setSensors(unsigned char sensors)
{
	return mpu_set_sensors(sensors);
}

/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
/*   must be run as often as possible   */
/* check if data ready and threat data  */
/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
boolean vertaccel_dataReady() {
  
  short iaccel[3];
  long iquat[4];
  unsigned long timestamp;
  short sensors;
  unsigned char fifoCount;
  
 //  Serial.println("dataready");

  /* check if we have new data from imu */
  while( dmp_read_fifo(NULL,iaccel,iquat,&timestamp,&sensors,&fifoCount) == 0 ) {
    newData = true;
  }

  /* if new data compute vertical acceleration */
  if( newData ) {

   Serial.println("new data");

    /***************************/
    /* normalize and calibrate */
    /***************************/
    double accel[3]; 
    double quat[4]; 
    
    accel[0] = ((double)iaccel[0])/VERTACCEL_ACCEL_SCALE + accelCal[0];
    accel[1] = ((double)iaccel[1])/VERTACCEL_ACCEL_SCALE + accelCal[1];
    accel[2] = ((double)iaccel[2])/VERTACCEL_ACCEL_SCALE + accelCal[2];
        
    quat[0] = ((double)iquat[0])/VERTACCEL_QUAT_SCALE;
    quat[1] = ((double)iquat[1])/VERTACCEL_QUAT_SCALE;
    quat[2] = ((double)iquat[2])/VERTACCEL_QUAT_SCALE;
    quat[3] = ((double)iquat[3])/VERTACCEL_QUAT_SCALE;
    

    /******************************/
    /* real and vert acceleration */
    /******************************/
  
    /* compute upper direction from quaternions */
    double ux, uy, uz;
    ux = 2*(quat[1]*quat[3]-quat[0]*quat[2]);
    uy = 2*(quat[2]*quat[3]+quat[0]*quat[1]);
    uz = 2*(quat[0]*quat[0]+quat[3]*quat[3])-1;
        
    /* compute real acceleration (without gravity) */
    double rax, ray, raz;
    rax = accel[0] - ux;
    ray = accel[1] - uy;
    raz = accel[2] - uz;
    
        
    /* compute vertical acceleration */
    va = (ux*rax + uy*ray + uz*raz);
  }
 
  return newData;
}


/* send raw data for debugging or calibration */ 
boolean vertaccel_rawReady(double* accel, double* upVector, double* vertAccel) {
  
  short iaccel[3];
  long iquat[4];
  unsigned long timestamp;
  short sensors;
  unsigned char fifoCount;
  
  /* check if we have new data from imu */
  while( dmp_read_fifo(NULL,iaccel,iquat,&timestamp,&sensors,&fifoCount) == 0 ) {
    newData = true;
  }

  /* if new data compute vertical acceleration */
  if( newData ) {

    /*************/
    /* normalize */
    /*************/ 
    double quat[4]; 
    
    accel[0] = ((double)iaccel[0])/VERTACCEL_ACCEL_SCALE;
    accel[1] = ((double)iaccel[1])/VERTACCEL_ACCEL_SCALE;
    accel[2] = ((double)iaccel[2])/VERTACCEL_ACCEL_SCALE;
        
    quat[0] = ((double)iquat[0])/VERTACCEL_QUAT_SCALE;
    quat[1] = ((double)iquat[1])/VERTACCEL_QUAT_SCALE;
    quat[2] = ((double)iquat[2])/VERTACCEL_QUAT_SCALE;
    quat[3] = ((double)iquat[3])/VERTACCEL_QUAT_SCALE;
    

    /******************************/
    /* real and vert acceleration */
    /******************************/
  
    /* compute upper direction from quaternions */
    double ux, uy, uz;
    ux = 2*(quat[1]*quat[3]-quat[0]*quat[2]);
    uy = 2*(quat[2]*quat[3]+quat[0]*quat[1]);
    uz = 2*(quat[0]*quat[0]+quat[3]*quat[3])-1;
        
    /* compute real acceleration (without gravity) */
    double rax, ray, raz;
    rax = accel[0] - ux;
    ray = accel[1] - uy;
    raz = accel[2] - uz;
    
        
    /* compute vertical acceleration */
    upVector[0] = ux;
    upVector[1] = uy;
    upVector[2] = uz;
    *vertAccel = (ux*rax + uy*ray + uz*raz);
  }
 
  return newData;
}


/* must be run before reading values */
void vertaccel_updateData() {

  /* start a new acceleration computation */
  newData = false;
}


/* get vertical acceleration */
double vertaccel_getValue() {
  return va * VERTACCEL_G_TO_MS;
}
