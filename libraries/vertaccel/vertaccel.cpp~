#include "vertaccel.h"

#include <Arduino.h>

#include <inv_mpu.h>
#include <inv_mpu_dmp_motion_driver.h>
#include "I2Cdev.h"


/******************/
/* data variables */
/******************/

static boolean newData;

/* accelerometer calibration */
static double accelCorrX, accelCorrY, accelCorrZ;

/* acceleration */
static short accel[3];

/* vertical acceleration */
static double va;

/********************/
/* public functions */
/********************/

/* init vertaccel */
int vertaccel_init() {

  /* setting imu */
  mpu_select_device(0);
  mpu_init_structures();
  mpu_init(NULL);
  mpu_set_sensors(INV_XYZ_GYRO|INV_XYZ_ACCEL); 
  mpu_set_gyro_fsr(VERTACCEL_GIRO_FSR);
  mpu_set_accel_fsr(VERTACCEL_ACCEL_FSR);
  mpu_configure_fifo(INV_XYZ_GYRO|INV_XYZ_ACCEL);

  /* setting dmp */
  dmp_select_device(0);
  dmp_init_structures();
  dmp_load_motion_driver_firmware();
  dmp_set_fifo_rate(VERTACCEL_FIFO_RATE);
  mpu_set_dmp_state(1);
  dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT|DMP_FEATURE_SEND_RAW_ACCEL); 

  /* init data variables */
  newData = false;
  accelCorrX = VERTACCEL_ACCEL_CORR_X;
  accelCorrY = VERTACCEL_ACCEL_CORR_Y;
  accelCorrZ = VERTACCEL_ACCEL_CORR_Z;
  
}

/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
/*   must be run as often sa possible   */
/* check if data ready and threat data  */
/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
boolean vertaccel_dataReady() {
 
  long quat[4];
  short sensors;
  unsigned char fifoCount;

  double naccel[3];
  double nquat[4];
  double rax, ray, raz;
  
  /* check if we have new data from imu */
  while( dmp_read_fifo(NULL,accel,quat,&timestamp,&sensors,&fifoCount) == 0 ) {
    newData = true;
  }

  /* if new data */
  //!!!!

    /************************/
    /* clear if new measure */
    /************************/
    if( ! newData ) {
      rax = 0;
      ray = 0;
      raz = 0;
      va = 0;
      previousMeasureTimestamp = 0;
      measureDuration = VERTACCEL_BASE_MEASURE_DURATION;
    }

    /* we have new data */
    newData = true;

    /***************************/
    /* normalize and calibrate */
    /***************************/
    naccel[0] = ((double)accel[0])/VERTACCEL_ACCEL_SCALE + VERTACCEL_ACCEL_CORR_X;
    naccel[1] = ((double)accel[1])/VERTACCEL_ACCEL_SCALE + VERTACCEL_ACCEL_CORR_Y;
    naccel[2] = ((double)accel[2])/VERTACCEL_ACCEL_SCALE + VERTACCEL_ACCEL_CORR_Z;
        
    nquat[0] = ((double)quat[0])/VERTACCEL_QUAT_SCALE;
    nquat[1] = ((double)quat[1])/VERTACCEL_QUAT_SCALE;
    nquat[2] = ((double)quat[2])/VERTACCEL_QUAT_SCALE;
    nquat[3] = ((double)quat[3])/VERTACCEL_QUAT_SCALE;
    

    /******************************/
    /* real and vert acceleration */
    /******************************/

    /* compute upper direction from quaternions */
    double ux, uy, uz;
    ux = 2*(nquat[1]*nquat[3]-nquat[0]*nquat[2]);
    uy = 2*(nquat[2]*nquat[3]+nquat[0]*nquat[1]);
    uz = 2*(nquat[0]*nquat[0]+nquat[3]*nquat[3])-1;
        
    /* compute real acceleration (without gravity) */
    double currentRax, currentRay, currentRaz;
    currentRax = naccel[0] - ux;
    currentRay = naccel[1] - uy;
    currentRaz = naccel[2] - uz;
        
    /* compute vertical acceleration */
    double currentVa;
    currentVa = (ux*currentRax + uy*currentRay + uz*currentRaz);

    /***************/
    /* update data */
    /***************/

    /* compute duration */
    if( previousMeasureTimestamp != 0 ) {
      measureDuration += timestamp - previousMeasureTimestamp;
    }
    previousMeasureTimestamp = timestamp;

    /* sum accelerations */
    rax += currentRax;
    ray += currentRay;
    raz += currentRaz;
    //va  += currentVa;
    va = (naccel[2] - 1.0);
  }

  return newData;
}

/* must be run before reading values */
void vertaccel_updateData() {

  /* compure final duration */
  /*
  unsigned long currentTimestamp = millis();
  measureDuration += currentTimestamp - previousMeasureTimestamp;
  previousMeasureTimestamp = currentTimestamp;
  */

  /* start a new acceleration computation */
  newData = false;
}

/* get vertical acceleration */
double vertaccel_getValue() {
  return va * VERTACCEL_G_TO_MS;
}






  
